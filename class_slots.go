// Code generated by gen_slots.py. DO NOT EDIT.

// This file is automatically generated.  To regenerate:
//   go generate ./...

package py

// #include "utils.h"
import "C"

import (
	"reflect"
	"unsafe"
)

// ===============================================================

type tp_repr interface {
	Repr() (Object, error)
}
type tp_hash interface {
	Hash() (int, error)
}
type tp_call interface {
	Call(*Tuple, *Dict) (Object, error)
}
type tp_str interface {
	Str() (Object, error)
}
type tp_getattro interface {
	GetAttr(Object) (Object, error)
}
type tp_setattro interface {
	SetAttr(Object, Object) error
}
type tp_richcompare interface {
	RichCompare(Object, Op) (Object, error)
}
type tp_iter interface {
	Iter() (Iterator, error)
}
type tp_iternext interface {
	Next() (Object, error)
}
type tp_descr_get interface {
	DescrGet(Object, Object) (Object, error)
}
type tp_descr_set interface {
	DescrSet(Object, Object) error
}
type tp_init interface {
	Init(*Tuple, *Dict) error
}
type am_await interface {
	Await() (Object, error)
}
type am_aiter interface {
	AsyncIter() (Object, error)
}
type am_anext interface {
	AsyncNext() (Object, error)
}
type am_send interface {
	AsyncSend(Object) (Object, SendResult, error)
}
type nb_add interface {
	Add(Object) (Object, error)
}
type nb_inplace_add interface {
	InPlaceAdd(Object) (Object, error)
}
type nb_subtract interface {
	Subtract(Object) (Object, error)
}
type nb_inplace_subtract interface {
	InPlaceSubtract(Object) (Object, error)
}
type nb_multiply interface {
	Multiply(Object) (Object, error)
}
type nb_inplace_multiply interface {
	InPlaceMultiply(Object) (Object, error)
}
type nb_remainder interface {
	Remainder(Object) (Object, error)
}
type nb_inplace_remainder interface {
	InPlaceRemainder(Object) (Object, error)
}
type nb_divmod interface {
	Divmod(Object) (Object, error)
}
type nb_power interface {
	Power(Object, Object) (Object, error)
}
type nb_inplace_power interface {
	InPlacePower(Object, Object) (Object, error)
}
type nb_negative interface {
	Negative() (Object, error)
}
type nb_positive interface {
	Positive() (Object, error)
}
type nb_absolute interface {
	Absolute() (Object, error)
}
type nb_bool interface {
	Bool() (bool, error)
}
type nb_invert interface {
	Invert() (Object, error)
}
type nb_lshift interface {
	LShift(Object) (Object, error)
}
type nb_inplace_lshift interface {
	InPlaceLShift(Object) (Object, error)
}
type nb_rshift interface {
	RShift(Object) (Object, error)
}
type nb_inplace_rshift interface {
	InPlaceRShift(Object) (Object, error)
}
type nb_and interface {
	And(Object) (Object, error)
}
type nb_inplace_and interface {
	InPlaceAnd(Object) (Object, error)
}
type nb_xor interface {
	Xor(Object) (Object, error)
}
type nb_inplace_xor interface {
	PyInPlaceXor(Object) (Object, error)
}
type nb_or interface {
	Or(Object) (Object, error)
}
type nb_inplace_or interface {
	PyInPlaceOr(Object) (Object, error)
}
type nb_int interface {
	Long() (*Long, error)
}
type nb_float interface {
	Float() (*Float, error)
}
type nb_floor_divide interface {
	FloorDivide(Object) (Object, error)
}
type nb_inplace_floor_divide interface {
	InPlaceFloorDivide(Object) (Object, error)
}
type nb_true_divide interface {
	TrueDivide(Object) (Object, error)
}
type nb_inplace_true_divide interface {
	InPlaceTrueDivide(Object) (Object, error)
}
type nb_index interface {
	Index() (*Long, error)
}
type nb_matrix_multiply interface {
	MatrixMultiply(Object) (Object, error)
}
type nb_inplace_matrix_multiply interface {
	InPlaceMatrixMultiply(Object) (Object, error)
}
type mp_length interface {
	PyMappingLen() int
}
type mp_subscript interface {
	Subscript(Object) (Object, error)
}
type mp_ass_subscript interface {
	AssSubscript(Object, Object) error
}
type sq_length interface {
	Len() int
}
type sq_concat interface {
	Concat(Object) (Object, error)
}
type sq_repeat interface {
	Repeat(Object, int) (Object, error)
}
type sq_item interface {
	GetIndex(int) (Object, error)
}
type sq_ass_item interface {
	SetIndex(int, Object) error
}
type sq_contains interface {
	Contains(Object) (bool, error)
}
type sq_inplace_concat interface {
	InPlaceConcat(Object) (Object, error)
}
type sq_inplace_repeat interface {
	InPlaceRepeat(Object, int) (Object, error)
}
type bf_getbuffer interface {
	GetBuffer(Object, int) error
}
type bf_releasebuffer interface {
	ReleaseBuffer(Object)
}

// ===============================================================
// ===============================================================

//export goClassSlot_tp_repr
func goClassSlot_tp_repr(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(tp_repr)

	ret, err := co.Repr()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_tp_hash
func goClassSlot_tp_hash(obj unsafe.Pointer) C.long {
	co := newObject((*C.PyObject)(obj)).(tp_hash)

	ret, err := co.Hash()
	if err != nil {
		raise(err)
		return -1
	} else if ret == -1 {
		return -2
	}

	return C.long(ret)
}
//export goClassSlot_tp_call
func goClassSlot_tp_call(obj, args, kwds unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(tp_call)

	a := newTuple((*C.PyObject)(args))
	k := newDict((*C.PyObject)(kwds))
	ret, err := co.Call(a, k)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_tp_str
func goClassSlot_tp_str(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(tp_str)

	ret, err := co.Str()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_tp_getattro
func goClassSlot_tp_getattro(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(tp_getattro)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.GetAttr(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_tp_setattro
func goClassSlot_tp_setattro(obj, arg1, arg2 unsafe.Pointer) int {
	co := newObject((*C.PyObject)(obj)).(tp_setattro)

	o1 := newObject((*C.PyObject)(arg1))
	o2 := newObject((*C.PyObject)(arg2))
	if err := co.SetAttr(o1, o2); err != nil {
		raise(err)
		return -1
	}

	return 0
}
//export goClassSlot_tp_richcompare
func goClassSlot_tp_richcompare(obj, arg1 unsafe.Pointer, arg2 C.int) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(tp_richcompare)

	o := newObject((*C.PyObject)(arg1))
	ret, err := co.RichCompare(o, Op(arg2))
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_tp_iter
func goClassSlot_tp_iter(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(tp_iter)

	ret, err := co.Iter()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_tp_iternext
func goClassSlot_tp_iternext(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(tp_iternext)

	ret, err := co.Next()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_tp_descr_get
func goClassSlot_tp_descr_get(obj, arg1, arg2 unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(tp_descr_get)

	o1 := newObject((*C.PyObject)(arg1))
	o2 := newObject((*C.PyObject)(arg2))
	ret, err := co.DescrGet(o1, o2)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_tp_descr_set
func goClassSlot_tp_descr_set(obj, arg1, arg2 unsafe.Pointer) int {
	co := newObject((*C.PyObject)(obj)).(tp_descr_set)

	o1 := newObject((*C.PyObject)(arg1))
	o2 := newObject((*C.PyObject)(arg2))
	if err := co.DescrSet(o1, o2); err != nil {
		raise(err)
		return -1
	}

	return 0
}
//export goClassSlot_tp_init
func goClassSlot_tp_init(obj, args, kwds unsafe.Pointer) int {
	co := newObject((*C.PyObject)(obj)).(tp_init)

	a := newTuple((*C.PyObject)(args))
	k := newDict((*C.PyObject)(kwds))
	if err := co.Init(a, k); err != nil {
		raise(err)
		return -1
	}

	return 0
}
//export goClassSlot_am_await
func goClassSlot_am_await(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(am_await)

	ret, err := co.Await()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_am_aiter
func goClassSlot_am_aiter(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(am_aiter)

	ret, err := co.AsyncIter()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_am_anext
func goClassSlot_am_anext(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(am_anext)

	ret, err := co.AsyncNext()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_am_send
func goClassSlot_am_send(obj, arg, out unsafe.Pointer) C.PySendResult {
	co := newObject((*C.PyObject)(obj)).(am_send)

	o := newObject((*C.PyObject)(arg))
	result := (**C.PyObject)(out)
	ret, res, err := co.AsyncSend(o)
	if err != nil {
		raise(err)
		*result = nil
		return C.PYGEN_ERROR
	}

	*result = c(ret)
	return C.PySendResult(res)
}
//export goClassSlot_nb_add
func goClassSlot_nb_add(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_add)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Add(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_add
func goClassSlot_nb_inplace_add(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_add)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceAdd(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_subtract
func goClassSlot_nb_subtract(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_subtract)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Subtract(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_subtract
func goClassSlot_nb_inplace_subtract(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_subtract)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceSubtract(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_multiply
func goClassSlot_nb_multiply(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_multiply)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Multiply(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_multiply
func goClassSlot_nb_inplace_multiply(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_multiply)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceMultiply(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_remainder
func goClassSlot_nb_remainder(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_remainder)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Remainder(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_remainder
func goClassSlot_nb_inplace_remainder(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_remainder)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceRemainder(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_divmod
func goClassSlot_nb_divmod(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_divmod)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Divmod(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_power
func goClassSlot_nb_power(obj, arg1, arg2 unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_power)

	o1 := newObject((*C.PyObject)(arg1))
	o2 := newObject((*C.PyObject)(arg2))
	ret, err := co.Power(o1, o2)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_power
func goClassSlot_nb_inplace_power(obj, arg1, arg2 unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_power)

	o1 := newObject((*C.PyObject)(arg1))
	o2 := newObject((*C.PyObject)(arg2))
	ret, err := co.InPlacePower(o1, o2)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_negative
func goClassSlot_nb_negative(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_negative)

	ret, err := co.Negative()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_positive
func goClassSlot_nb_positive(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_positive)

	ret, err := co.Positive()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_absolute
func goClassSlot_nb_absolute(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_absolute)

	ret, err := co.Absolute()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_bool
func goClassSlot_nb_bool(obj unsafe.Pointer) int {
	co := newObject((*C.PyObject)(obj)).(nb_bool)

	ret, err := co.Bool()
	if err != nil {
		raise(err)
		return -1
	}

	if ret {
		return 1
	}

	return 0
}
//export goClassSlot_nb_invert
func goClassSlot_nb_invert(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_invert)

	ret, err := co.Invert()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_lshift
func goClassSlot_nb_lshift(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_lshift)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.LShift(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_lshift
func goClassSlot_nb_inplace_lshift(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_lshift)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceLShift(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_rshift
func goClassSlot_nb_rshift(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_rshift)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.RShift(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_rshift
func goClassSlot_nb_inplace_rshift(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_rshift)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceRShift(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_and
func goClassSlot_nb_and(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_and)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.And(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_and
func goClassSlot_nb_inplace_and(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_and)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceAnd(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_xor
func goClassSlot_nb_xor(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_xor)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Xor(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_xor
func goClassSlot_nb_inplace_xor(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_xor)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.PyInPlaceXor(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_or
func goClassSlot_nb_or(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_or)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Or(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_or
func goClassSlot_nb_inplace_or(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_or)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.PyInPlaceOr(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_int
func goClassSlot_nb_int(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_int)

	ret, err := co.Long()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_float
func goClassSlot_nb_float(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_float)

	ret, err := co.Float()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_floor_divide
func goClassSlot_nb_floor_divide(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_floor_divide)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.FloorDivide(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_floor_divide
func goClassSlot_nb_inplace_floor_divide(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_floor_divide)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceFloorDivide(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_true_divide
func goClassSlot_nb_true_divide(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_true_divide)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.TrueDivide(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_true_divide
func goClassSlot_nb_inplace_true_divide(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_true_divide)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceTrueDivide(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_index
func goClassSlot_nb_index(obj unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_index)

	ret, err := co.Index()
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_matrix_multiply
func goClassSlot_nb_matrix_multiply(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_matrix_multiply)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.MatrixMultiply(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_nb_inplace_matrix_multiply
func goClassSlot_nb_inplace_matrix_multiply(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(nb_inplace_matrix_multiply)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceMatrixMultiply(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_mp_length
func goClassSlot_mp_length(obj unsafe.Pointer) C.Py_ssize_t {
	co := newObject((*C.PyObject)(obj)).(mp_length)

	return C.Py_ssize_t(co.PyMappingLen())
}
//export goClassSlot_mp_subscript
func goClassSlot_mp_subscript(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(mp_subscript)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Subscript(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_mp_ass_subscript
func goClassSlot_mp_ass_subscript(obj, arg1, arg2 unsafe.Pointer) int {
	co := newObject((*C.PyObject)(obj)).(mp_ass_subscript)

	o1 := newObject((*C.PyObject)(arg1))
	o2 := newObject((*C.PyObject)(arg2))
	if err := co.AssSubscript(o1, o2); err != nil {
		raise(err)
		return -1
	}

	return 0
}
//export goClassSlot_sq_length
func goClassSlot_sq_length(obj unsafe.Pointer) C.Py_ssize_t {
	co := newObject((*C.PyObject)(obj)).(sq_length)

	return C.Py_ssize_t(co.Len())
}
//export goClassSlot_sq_concat
func goClassSlot_sq_concat(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(sq_concat)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Concat(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_sq_repeat
func goClassSlot_sq_repeat(obj, arg1 unsafe.Pointer, arg2 C.Py_ssize_t) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(sq_repeat)

	o := newObject((*C.PyObject)(arg1))
	ret, err := co.Repeat(o, int(arg2))
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_sq_item
func goClassSlot_sq_item(obj unsafe.Pointer, arg1 C.Py_ssize_t) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(sq_item)

	ret, err := co.GetIndex(int(arg1))
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_sq_ass_item
func goClassSlot_sq_ass_item(obj unsafe.Pointer, arg1 C.Py_ssize_t, arg2 unsafe.Pointer) C.int {
	co := newObject((*C.PyObject)(obj)).(sq_ass_item)

	a := newObject((*C.PyObject)(arg2))
	if err := co.SetIndex(int(arg1), a); err != nil {
		raise(err)
		return -1
	}

	return 0
}
//export goClassSlot_sq_contains
func goClassSlot_sq_contains(obj, arg unsafe.Pointer) int {
	co := newObject((*C.PyObject)(obj)).(sq_contains)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.Contains(o)
	if err != nil {
		raise(err)
		return -1
	}

	if ret {
		return 1
	}

	return 0
}
//export goClassSlot_sq_inplace_concat
func goClassSlot_sq_inplace_concat(obj, arg unsafe.Pointer) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(sq_inplace_concat)

	o := newObject((*C.PyObject)(arg))
	ret, err := co.InPlaceConcat(o)
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_sq_inplace_repeat
func goClassSlot_sq_inplace_repeat(obj, arg1 unsafe.Pointer, arg2 C.Py_ssize_t) unsafe.Pointer {
	co := newObject((*C.PyObject)(obj)).(sq_inplace_repeat)

	o := newObject((*C.PyObject)(arg1))
	ret, err := co.InPlaceRepeat(o, int(arg2))
	if err != nil {
		raise(err)
		return nil
	}

	return unsafe.Pointer(c(ret))
}
//export goClassSlot_bf_getbuffer
func goClassSlot_bf_getbuffer(obj, arg1 unsafe.Pointer, arg2 C.int) int {
	co := newObject((*C.PyObject)(obj)).(bf_getbuffer)

	o := newObject((*C.PyObject)(arg1))
	if err := co.GetBuffer(o, int(arg2)); err != nil {
		raise(err)
		return -1
	}

	return 0
}
//export goClassSlot_bf_releasebuffer
func goClassSlot_bf_releasebuffer(obj, arg unsafe.Pointer) {
	co := newObject((*C.PyObject)(obj)).(bf_releasebuffer)

	o := newObject((*C.PyObject)(arg))
	co.ReleaseBuffer(o)
}

// ===============================================================
// ===============================================================

var slotMap = map[C.uint64_t]reflect.Type{
	C.CLASS_HAS_TP_REPR: reflect.TypeOf((*tp_repr)(nil)).Elem(),
	C.CLASS_HAS_TP_HASH: reflect.TypeOf((*tp_hash)(nil)).Elem(),
	C.CLASS_HAS_TP_CALL: reflect.TypeOf((*tp_call)(nil)).Elem(),
	C.CLASS_HAS_TP_STR: reflect.TypeOf((*tp_str)(nil)).Elem(),
	C.CLASS_HAS_TP_GETATTRO: reflect.TypeOf((*tp_getattro)(nil)).Elem(),
	C.CLASS_HAS_TP_SETATTRO: reflect.TypeOf((*tp_setattro)(nil)).Elem(),
	C.CLASS_HAS_TP_RICHCOMPARE: reflect.TypeOf((*tp_richcompare)(nil)).Elem(),
	C.CLASS_HAS_TP_ITER: reflect.TypeOf((*tp_iter)(nil)).Elem(),
	C.CLASS_HAS_TP_ITERNEXT: reflect.TypeOf((*tp_iternext)(nil)).Elem(),
	C.CLASS_HAS_TP_DESCR_GET: reflect.TypeOf((*tp_descr_get)(nil)).Elem(),
	C.CLASS_HAS_TP_DESCR_SET: reflect.TypeOf((*tp_descr_set)(nil)).Elem(),
	C.CLASS_HAS_TP_INIT: reflect.TypeOf((*tp_init)(nil)).Elem(),
	C.CLASS_HAS_AM_AWAIT: reflect.TypeOf((*am_await)(nil)).Elem(),
	C.CLASS_HAS_AM_AITER: reflect.TypeOf((*am_aiter)(nil)).Elem(),
	C.CLASS_HAS_AM_ANEXT: reflect.TypeOf((*am_anext)(nil)).Elem(),
	C.CLASS_HAS_AM_SEND: reflect.TypeOf((*am_send)(nil)).Elem(),
	C.CLASS_HAS_NB_ADD: reflect.TypeOf((*nb_add)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_ADD: reflect.TypeOf((*nb_inplace_add)(nil)).Elem(),
	C.CLASS_HAS_NB_SUBTRACT: reflect.TypeOf((*nb_subtract)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_SUBTRACT: reflect.TypeOf((*nb_inplace_subtract)(nil)).Elem(),
	C.CLASS_HAS_NB_MULTIPLY: reflect.TypeOf((*nb_multiply)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_MULTIPLY: reflect.TypeOf((*nb_inplace_multiply)(nil)).Elem(),
	C.CLASS_HAS_NB_REMAINDER: reflect.TypeOf((*nb_remainder)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_REMAINDER: reflect.TypeOf((*nb_inplace_remainder)(nil)).Elem(),
	C.CLASS_HAS_NB_DIVMOD: reflect.TypeOf((*nb_divmod)(nil)).Elem(),
	C.CLASS_HAS_NB_POWER: reflect.TypeOf((*nb_power)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_POWER: reflect.TypeOf((*nb_inplace_power)(nil)).Elem(),
	C.CLASS_HAS_NB_NEGATIVE: reflect.TypeOf((*nb_negative)(nil)).Elem(),
	C.CLASS_HAS_NB_POSITIVE: reflect.TypeOf((*nb_positive)(nil)).Elem(),
	C.CLASS_HAS_NB_ABSOLUTE: reflect.TypeOf((*nb_absolute)(nil)).Elem(),
	C.CLASS_HAS_NB_BOOL: reflect.TypeOf((*nb_bool)(nil)).Elem(),
	C.CLASS_HAS_NB_INVERT: reflect.TypeOf((*nb_invert)(nil)).Elem(),
	C.CLASS_HAS_NB_LSHIFT: reflect.TypeOf((*nb_lshift)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_LSHIFT: reflect.TypeOf((*nb_inplace_lshift)(nil)).Elem(),
	C.CLASS_HAS_NB_RSHIFT: reflect.TypeOf((*nb_rshift)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_RSHIFT: reflect.TypeOf((*nb_inplace_rshift)(nil)).Elem(),
	C.CLASS_HAS_NB_AND: reflect.TypeOf((*nb_and)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_AND: reflect.TypeOf((*nb_inplace_and)(nil)).Elem(),
	C.CLASS_HAS_NB_XOR: reflect.TypeOf((*nb_xor)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_XOR: reflect.TypeOf((*nb_inplace_xor)(nil)).Elem(),
	C.CLASS_HAS_NB_OR: reflect.TypeOf((*nb_or)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_OR: reflect.TypeOf((*nb_inplace_or)(nil)).Elem(),
	C.CLASS_HAS_NB_INT: reflect.TypeOf((*nb_int)(nil)).Elem(),
	C.CLASS_HAS_NB_FLOAT: reflect.TypeOf((*nb_float)(nil)).Elem(),
	C.CLASS_HAS_NB_FLOOR_DIVIDE: reflect.TypeOf((*nb_floor_divide)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_FLOOR_DIVIDE: reflect.TypeOf((*nb_inplace_floor_divide)(nil)).Elem(),
	C.CLASS_HAS_NB_TRUE_DIVIDE: reflect.TypeOf((*nb_true_divide)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_TRUE_DIVIDE: reflect.TypeOf((*nb_inplace_true_divide)(nil)).Elem(),
	C.CLASS_HAS_NB_INDEX: reflect.TypeOf((*nb_index)(nil)).Elem(),
	C.CLASS_HAS_NB_MATRIX_MULTIPLY: reflect.TypeOf((*nb_matrix_multiply)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_MATRIX_MULTIPLY: reflect.TypeOf((*nb_inplace_matrix_multiply)(nil)).Elem(),
	C.CLASS_HAS_MP_LENGTH: reflect.TypeOf((*mp_length)(nil)).Elem(),
	C.CLASS_HAS_MP_SUBSCRIPT: reflect.TypeOf((*mp_subscript)(nil)).Elem(),
	C.CLASS_HAS_MP_ASS_SUBSCRIPT: reflect.TypeOf((*mp_ass_subscript)(nil)).Elem(),
	C.CLASS_HAS_SQ_LENGTH: reflect.TypeOf((*sq_length)(nil)).Elem(),
	C.CLASS_HAS_SQ_CONCAT: reflect.TypeOf((*sq_concat)(nil)).Elem(),
	C.CLASS_HAS_SQ_REPEAT: reflect.TypeOf((*sq_repeat)(nil)).Elem(),
	C.CLASS_HAS_SQ_ITEM: reflect.TypeOf((*sq_item)(nil)).Elem(),
	C.CLASS_HAS_SQ_ASS_ITEM: reflect.TypeOf((*sq_ass_item)(nil)).Elem(),
	C.CLASS_HAS_SQ_CONTAINS: reflect.TypeOf((*sq_contains)(nil)).Elem(),
	C.CLASS_HAS_SQ_INPLACE_CONCAT: reflect.TypeOf((*sq_inplace_concat)(nil)).Elem(),
	C.CLASS_HAS_SQ_INPLACE_REPEAT: reflect.TypeOf((*sq_inplace_repeat)(nil)).Elem(),
	C.CLASS_HAS_BF_GETBUFFER: reflect.TypeOf((*bf_getbuffer)(nil)).Elem(),
	C.CLASS_HAS_BF_RELEASEBUFFER: reflect.TypeOf((*bf_releasebuffer)(nil)).Elem(),
}

// ===============================================================
