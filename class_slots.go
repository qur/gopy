// Code generated by gen_slots.py. DO NOT EDIT.

// This file is automatically generated.  To regenerate:
//   go generate ./...

package py

// #include "utils.h"
import "C"

import (
	"reflect"
	"unsafe"
)

// ===============================================================

type tp_repr interface {
	Repr() (Object, error)
}
type tp_hash interface {
	Hash() (int, error)
}
type tp_call interface {
	Call(*Tuple, *Dict) (Object, error)
}
type tp_str interface {
	Str() (Object, error)
}
type tp_getattro interface {
	GetAttr(Object) (Object, error)
}
type tp_setattro interface {
	SetAttr(Object, Object) error
}
type tp_richcompare interface {
	RichCompare(Object, Op) (Object, error)
}
type tp_iter interface {
	Iter() (Iterator, error)
}
type tp_iternext interface {
	Next() (Object, error)
}
type tp_descr_get interface {
	DescrGet(Object, Object) (Object, error)
}
type tp_descr_set interface {
	DescrSet(Object, Object) error
}
type tp_init interface {
	Init(*Tuple, *Dict) error
}
type am_await interface {
	Await() (Object, error)
}
type am_aiter interface {
	AsyncIter() (Object, error)
}
type am_anext interface {
	AsyncNext() (Object, error)
}
type am_send interface {
	AsyncSend(Object) (Object, SendResult, error)
}
type nb_add interface {
	Add(Object) (Object, error)
}
type nb_inplace_add interface {
	InPlaceAdd(Object) (Object, error)
}
type nb_subtract interface {
	Subtract(Object) (Object, error)
}
type nb_inplace_subtract interface {
	InPlaceSubtract(Object) (Object, error)
}
type nb_multiply interface {
	Multiply(Object) (Object, error)
}
type nb_inplace_multiply interface {
	InPlaceMultiply(Object) (Object, error)
}
type nb_remainder interface {
	Remainder(Object) (Object, error)
}
type nb_inplace_remainder interface {
	InPlaceRemainder(Object) (Object, error)
}
type nb_divmod interface {
	Divmod(Object) (Object, error)
}
type nb_power interface {
	Power(Object, Object) (Object, error)
}
type nb_inplace_power interface {
	InPlacePower(Object, Object) (Object, error)
}
type nb_negative interface {
	Negative() (Object, error)
}
type nb_positive interface {
	Positive() (Object, error)
}
type nb_absolute interface {
	Absolute() (Object, error)
}
type nb_bool interface {
	Bool() (bool, error)
}
type nb_invert interface {
	Invert() (Object, error)
}
type nb_lshift interface {
	LShift(Object) (Object, error)
}
type nb_inplace_lshift interface {
	InPlaceLShift(Object) (Object, error)
}
type nb_rshift interface {
	RShift(Object) (Object, error)
}
type nb_inplace_rshift interface {
	InPlaceRShift(Object) (Object, error)
}
type nb_and interface {
	And(Object) (Object, error)
}
type nb_inplace_and interface {
	InPlaceAnd(Object) (Object, error)
}
type nb_xor interface {
	Xor(Object) (Object, error)
}
type nb_inplace_xor interface {
	PyInPlaceXor(Object) (Object, error)
}
type nb_or interface {
	Or(Object) (Object, error)
}
type nb_inplace_or interface {
	PyInPlaceOr(Object) (Object, error)
}
type nb_int interface {
	Long() (*Long, error)
}
type nb_float interface {
	Float() (*Float, error)
}
type nb_floor_divide interface {
	FloorDivide(Object) (Object, error)
}
type nb_inplace_floor_divide interface {
	InPlaceFloorDivide(Object) (Object, error)
}
type nb_true_divide interface {
	TrueDivide(Object) (Object, error)
}
type nb_inplace_true_divide interface {
	InPlaceTrueDivide(Object) (Object, error)
}
type nb_index interface {
	Index() (*Long, error)
}
type nb_matrix_multiply interface {
	MatrixMultiply(Object) (Object, error)
}
type nb_inplace_matrix_multiply interface {
	InPlaceMatrixMultiply(Object) (Object, error)
}
type mp_length interface {
	PyMappingLen() int
}
type mp_subscript interface {
	Subscript(Object) (Object, error)
}
type mp_ass_subscript interface {
	AssSubscript(Object, Object) error
}
type sq_length interface {
	Len() int
}
type sq_concat interface {
	Concat(Object) (Object, error)
}
type sq_repeat interface {
	Repeat(Object, int) (Object, error)
}
type sq_item interface {
	GetIndex(int) (Object, error)
}
type sq_ass_item interface {
	SetIndex(int, Object) error
}
type sq_contains interface {
	Contains(Object) (bool, error)
}
type sq_inplace_concat interface {
	InPlaceConcat(Object) (Object, error)
}
type sq_inplace_repeat interface {
	InPlaceRepeat(Object, int) (Object, error)
}
type bf_getbuffer interface {
	GetBuffer(Object, int) error
}
type bf_releasebuffer interface {
	ReleaseBuffer(Object)
}

// ===============================================================
// ===============================================================

//export goClassSlot_tp_repr
func goClassSlot_tp_repr(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(tp_repr)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_repr)
	}
	if !ok {
		panic("failed to find valid type for tp_repr")
	}

	return ce(co.Repr())
}
//export goClassSlot_tp_hash
func goClassSlot_tp_hash(obj *C.PyObject) C.long {
	co, ok := getClassObject(obj).(tp_hash)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_hash)
	}
	if !ok {
		panic("failed to find valid type for tp_hash")
	}

	ret, err := co.Hash()
	if err != nil {
		raise(err)
		return -1
	} else if ret == -1 {
		return -2
	}

	return C.long(ret)
}
//export goClassSlot_tp_call
func goClassSlot_tp_call(obj, args, kwds *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(tp_call)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_call)
	}
	if !ok {
		panic("failed to find valid type for tp_call")
	}

	return ce(co.Call(newTuple(args), newDict(kwds)))
}
//export goClassSlot_tp_str
func goClassSlot_tp_str(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(tp_str)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_str)
	}
	if !ok {
		panic("failed to find valid type for tp_str")
	}

	return ce(co.Str())
}
//export goClassSlot_tp_getattro
func goClassSlot_tp_getattro(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(tp_getattro)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_getattro)
	}
	if !ok {
		panic("failed to find valid type for tp_getattro")
	}

	return ce(co.GetAttr(newObject(arg)))
}
//export goClassSlot_tp_setattro
func goClassSlot_tp_setattro(obj, arg1, arg2 *C.PyObject) C.int {
	co, ok := getClassObject(obj).(tp_setattro)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_setattro)
	}
	if !ok {
		panic("failed to find valid type for tp_setattro")
	}

	return err2Int(co.SetAttr(newObject(arg1), newObject(arg2)))
}
//export goClassSlot_tp_richcompare
func goClassSlot_tp_richcompare(obj, arg1 *C.PyObject, arg2 C.int) *C.PyObject {
	co, ok := getClassObject(obj).(tp_richcompare)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_richcompare)
	}
	if !ok {
		panic("failed to find valid type for tp_richcompare")
	}

	return ce(co.RichCompare(newObject(arg1), Op(arg2)))
}
//export goClassSlot_tp_iter
func goClassSlot_tp_iter(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(tp_iter)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_iter)
	}
	if !ok {
		panic("failed to find valid type for tp_iter")
	}

	return ce(co.Iter())
}
//export goClassSlot_tp_iternext
func goClassSlot_tp_iternext(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(tp_iternext)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_iternext)
	}
	if !ok {
		panic("failed to find valid type for tp_iternext")
	}

	return ce(co.Next())
}
//export goClassSlot_tp_descr_get
func goClassSlot_tp_descr_get(obj, arg1, arg2 *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(tp_descr_get)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_descr_get)
	}
	if !ok {
		panic("failed to find valid type for tp_descr_get")
	}

	return ce(co.DescrGet(newObject(arg1), newObject(arg2)))
}
//export goClassSlot_tp_descr_set
func goClassSlot_tp_descr_set(obj, arg1, arg2 *C.PyObject) C.int {
	co, ok := getClassObject(obj).(tp_descr_set)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_descr_set)
	}
	if !ok {
		panic("failed to find valid type for tp_descr_set")
	}

	return err2Int(co.DescrSet(newObject(arg1), newObject(arg2)))
}
//export goClassSlot_tp_init
func goClassSlot_tp_init(obj, args, kwds *C.PyObject) C.int {
	co, ok := getClassObject(obj).(tp_init)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(tp_init)
	}
	if !ok {
		panic("failed to find valid type for tp_init")
	}

	return err2Int(co.Init(newTuple(args), newDict(kwds)))
}
//export goClassSlot_am_await
func goClassSlot_am_await(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(am_await)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(am_await)
	}
	if !ok {
		panic("failed to find valid type for am_await")
	}

	return ce(co.Await())
}
//export goClassSlot_am_aiter
func goClassSlot_am_aiter(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(am_aiter)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(am_aiter)
	}
	if !ok {
		panic("failed to find valid type for am_aiter")
	}

	return ce(co.AsyncIter())
}
//export goClassSlot_am_anext
func goClassSlot_am_anext(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(am_anext)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(am_anext)
	}
	if !ok {
		panic("failed to find valid type for am_anext")
	}

	return ce(co.AsyncNext())
}
//export goClassSlot_am_send
func goClassSlot_am_send(obj, arg *C.PyObject, out unsafe.Pointer) C.PySendResult {
	co, ok := getClassObject(obj).(am_send)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(am_send)
	}
	if !ok {
		panic("failed to find valid type for am_send")
	}

	result := (**C.PyObject)(out)
	ret, res, err := co.AsyncSend(newObject(arg))
	if err != nil {
		raise(err)
		*result = nil
		return C.PYGEN_ERROR
	}

	*result = c(ret)
	return C.PySendResult(res)
}
//export goClassSlot_nb_add
func goClassSlot_nb_add(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_add)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_add)
	}
	if !ok {
		panic("failed to find valid type for nb_add")
	}

	return ce(co.Add(newObject(arg)))
}
//export goClassSlot_nb_inplace_add
func goClassSlot_nb_inplace_add(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_add)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_add)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_add")
	}

	return ce(co.InPlaceAdd(newObject(arg)))
}
//export goClassSlot_nb_subtract
func goClassSlot_nb_subtract(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_subtract)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_subtract)
	}
	if !ok {
		panic("failed to find valid type for nb_subtract")
	}

	return ce(co.Subtract(newObject(arg)))
}
//export goClassSlot_nb_inplace_subtract
func goClassSlot_nb_inplace_subtract(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_subtract)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_subtract)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_subtract")
	}

	return ce(co.InPlaceSubtract(newObject(arg)))
}
//export goClassSlot_nb_multiply
func goClassSlot_nb_multiply(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_multiply)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_multiply)
	}
	if !ok {
		panic("failed to find valid type for nb_multiply")
	}

	return ce(co.Multiply(newObject(arg)))
}
//export goClassSlot_nb_inplace_multiply
func goClassSlot_nb_inplace_multiply(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_multiply)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_multiply)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_multiply")
	}

	return ce(co.InPlaceMultiply(newObject(arg)))
}
//export goClassSlot_nb_remainder
func goClassSlot_nb_remainder(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_remainder)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_remainder)
	}
	if !ok {
		panic("failed to find valid type for nb_remainder")
	}

	return ce(co.Remainder(newObject(arg)))
}
//export goClassSlot_nb_inplace_remainder
func goClassSlot_nb_inplace_remainder(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_remainder)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_remainder)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_remainder")
	}

	return ce(co.InPlaceRemainder(newObject(arg)))
}
//export goClassSlot_nb_divmod
func goClassSlot_nb_divmod(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_divmod)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_divmod)
	}
	if !ok {
		panic("failed to find valid type for nb_divmod")
	}

	return ce(co.Divmod(newObject(arg)))
}
//export goClassSlot_nb_power
func goClassSlot_nb_power(obj, arg1, arg2 *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_power)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_power)
	}
	if !ok {
		panic("failed to find valid type for nb_power")
	}

	return ce(co.Power(newObject(arg1), newObject(arg2)))
}
//export goClassSlot_nb_inplace_power
func goClassSlot_nb_inplace_power(obj, arg1, arg2 *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_power)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_power)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_power")
	}

	return ce(co.InPlacePower(newObject(arg1), newObject(arg2)))
}
//export goClassSlot_nb_negative
func goClassSlot_nb_negative(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_negative)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_negative)
	}
	if !ok {
		panic("failed to find valid type for nb_negative")
	}

	return ce(co.Negative())
}
//export goClassSlot_nb_positive
func goClassSlot_nb_positive(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_positive)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_positive)
	}
	if !ok {
		panic("failed to find valid type for nb_positive")
	}

	return ce(co.Positive())
}
//export goClassSlot_nb_absolute
func goClassSlot_nb_absolute(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_absolute)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_absolute)
	}
	if !ok {
		panic("failed to find valid type for nb_absolute")
	}

	return ce(co.Absolute())
}
//export goClassSlot_nb_bool
func goClassSlot_nb_bool(obj *C.PyObject) C.int {
	co, ok := getClassObject(obj).(nb_bool)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_bool)
	}
	if !ok {
		panic("failed to find valid type for nb_bool")
	}

	return boolErr2Int(co.Bool())
}
//export goClassSlot_nb_invert
func goClassSlot_nb_invert(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_invert)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_invert)
	}
	if !ok {
		panic("failed to find valid type for nb_invert")
	}

	return ce(co.Invert())
}
//export goClassSlot_nb_lshift
func goClassSlot_nb_lshift(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_lshift)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_lshift)
	}
	if !ok {
		panic("failed to find valid type for nb_lshift")
	}

	return ce(co.LShift(newObject(arg)))
}
//export goClassSlot_nb_inplace_lshift
func goClassSlot_nb_inplace_lshift(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_lshift)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_lshift)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_lshift")
	}

	return ce(co.InPlaceLShift(newObject(arg)))
}
//export goClassSlot_nb_rshift
func goClassSlot_nb_rshift(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_rshift)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_rshift)
	}
	if !ok {
		panic("failed to find valid type for nb_rshift")
	}

	return ce(co.RShift(newObject(arg)))
}
//export goClassSlot_nb_inplace_rshift
func goClassSlot_nb_inplace_rshift(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_rshift)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_rshift)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_rshift")
	}

	return ce(co.InPlaceRShift(newObject(arg)))
}
//export goClassSlot_nb_and
func goClassSlot_nb_and(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_and)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_and)
	}
	if !ok {
		panic("failed to find valid type for nb_and")
	}

	return ce(co.And(newObject(arg)))
}
//export goClassSlot_nb_inplace_and
func goClassSlot_nb_inplace_and(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_and)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_and)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_and")
	}

	return ce(co.InPlaceAnd(newObject(arg)))
}
//export goClassSlot_nb_xor
func goClassSlot_nb_xor(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_xor)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_xor)
	}
	if !ok {
		panic("failed to find valid type for nb_xor")
	}

	return ce(co.Xor(newObject(arg)))
}
//export goClassSlot_nb_inplace_xor
func goClassSlot_nb_inplace_xor(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_xor)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_xor)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_xor")
	}

	return ce(co.PyInPlaceXor(newObject(arg)))
}
//export goClassSlot_nb_or
func goClassSlot_nb_or(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_or)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_or)
	}
	if !ok {
		panic("failed to find valid type for nb_or")
	}

	return ce(co.Or(newObject(arg)))
}
//export goClassSlot_nb_inplace_or
func goClassSlot_nb_inplace_or(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_or)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_or)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_or")
	}

	return ce(co.PyInPlaceOr(newObject(arg)))
}
//export goClassSlot_nb_int
func goClassSlot_nb_int(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_int)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_int)
	}
	if !ok {
		panic("failed to find valid type for nb_int")
	}

	return ce(co.Long())
}
//export goClassSlot_nb_float
func goClassSlot_nb_float(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_float)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_float)
	}
	if !ok {
		panic("failed to find valid type for nb_float")
	}

	return ce(co.Float())
}
//export goClassSlot_nb_floor_divide
func goClassSlot_nb_floor_divide(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_floor_divide)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_floor_divide)
	}
	if !ok {
		panic("failed to find valid type for nb_floor_divide")
	}

	return ce(co.FloorDivide(newObject(arg)))
}
//export goClassSlot_nb_inplace_floor_divide
func goClassSlot_nb_inplace_floor_divide(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_floor_divide)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_floor_divide)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_floor_divide")
	}

	return ce(co.InPlaceFloorDivide(newObject(arg)))
}
//export goClassSlot_nb_true_divide
func goClassSlot_nb_true_divide(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_true_divide)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_true_divide)
	}
	if !ok {
		panic("failed to find valid type for nb_true_divide")
	}

	return ce(co.TrueDivide(newObject(arg)))
}
//export goClassSlot_nb_inplace_true_divide
func goClassSlot_nb_inplace_true_divide(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_true_divide)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_true_divide)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_true_divide")
	}

	return ce(co.InPlaceTrueDivide(newObject(arg)))
}
//export goClassSlot_nb_index
func goClassSlot_nb_index(obj *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_index)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_index)
	}
	if !ok {
		panic("failed to find valid type for nb_index")
	}

	return ce(co.Index())
}
//export goClassSlot_nb_matrix_multiply
func goClassSlot_nb_matrix_multiply(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_matrix_multiply)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_matrix_multiply)
	}
	if !ok {
		panic("failed to find valid type for nb_matrix_multiply")
	}

	return ce(co.MatrixMultiply(newObject(arg)))
}
//export goClassSlot_nb_inplace_matrix_multiply
func goClassSlot_nb_inplace_matrix_multiply(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(nb_inplace_matrix_multiply)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(nb_inplace_matrix_multiply)
	}
	if !ok {
		panic("failed to find valid type for nb_inplace_matrix_multiply")
	}

	return ce(co.InPlaceMatrixMultiply(newObject(arg)))
}
//export goClassSlot_mp_length
func goClassSlot_mp_length(obj *C.PyObject) C.Py_ssize_t {
	co, ok := getClassObject(obj).(mp_length)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(mp_length)
	}
	if !ok {
		panic("failed to find valid type for mp_length")
	}

	return C.Py_ssize_t(co.PyMappingLen())
}
//export goClassSlot_mp_subscript
func goClassSlot_mp_subscript(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(mp_subscript)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(mp_subscript)
	}
	if !ok {
		panic("failed to find valid type for mp_subscript")
	}

	return ce(co.Subscript(newObject(arg)))
}
//export goClassSlot_mp_ass_subscript
func goClassSlot_mp_ass_subscript(obj, arg1, arg2 *C.PyObject) C.int {
	co, ok := getClassObject(obj).(mp_ass_subscript)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(mp_ass_subscript)
	}
	if !ok {
		panic("failed to find valid type for mp_ass_subscript")
	}

	return err2Int(co.AssSubscript(newObject(arg1), newObject(arg2)))
}
//export goClassSlot_sq_length
func goClassSlot_sq_length(obj *C.PyObject) C.Py_ssize_t {
	co, ok := getClassObject(obj).(sq_length)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(sq_length)
	}
	if !ok {
		panic("failed to find valid type for sq_length")
	}

	return C.Py_ssize_t(co.Len())
}
//export goClassSlot_sq_concat
func goClassSlot_sq_concat(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(sq_concat)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(sq_concat)
	}
	if !ok {
		panic("failed to find valid type for sq_concat")
	}

	return ce(co.Concat(newObject(arg)))
}
//export goClassSlot_sq_repeat
func goClassSlot_sq_repeat(obj, arg1 *C.PyObject, arg2 C.Py_ssize_t) *C.PyObject {
	co, ok := getClassObject(obj).(sq_repeat)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(sq_repeat)
	}
	if !ok {
		panic("failed to find valid type for sq_repeat")
	}

	return ce(co.Repeat(newObject(arg1), int(arg2)))
}
//export goClassSlot_sq_item
func goClassSlot_sq_item(obj *C.PyObject, arg1 C.Py_ssize_t) *C.PyObject {
	co, ok := getClassObject(obj).(sq_item)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(sq_item)
	}
	if !ok {
		panic("failed to find valid type for sq_item")
	}

	return ce(co.GetIndex(int(arg1)))
}
//export goClassSlot_sq_ass_item
func goClassSlot_sq_ass_item(obj *C.PyObject, arg1 C.Py_ssize_t, arg2 *C.PyObject) C.int {
	co, ok := getClassObject(obj).(sq_ass_item)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(sq_ass_item)
	}
	if !ok {
		panic("failed to find valid type for sq_ass_item")
	}

	return err2Int(co.SetIndex(int(arg1), newObject(arg2)))
}
//export goClassSlot_sq_contains
func goClassSlot_sq_contains(obj, arg *C.PyObject) C.int {
	co, ok := getClassObject(obj).(sq_contains)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(sq_contains)
	}
	if !ok {
		panic("failed to find valid type for sq_contains")
	}

	return boolErr2Int(co.Contains(newObject(arg)))
}
//export goClassSlot_sq_inplace_concat
func goClassSlot_sq_inplace_concat(obj, arg *C.PyObject) *C.PyObject {
	co, ok := getClassObject(obj).(sq_inplace_concat)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(sq_inplace_concat)
	}
	if !ok {
		panic("failed to find valid type for sq_inplace_concat")
	}

	return ce(co.InPlaceConcat(newObject(arg)))
}
//export goClassSlot_sq_inplace_repeat
func goClassSlot_sq_inplace_repeat(obj, arg1 *C.PyObject, arg2 C.Py_ssize_t) *C.PyObject {
	co, ok := getClassObject(obj).(sq_inplace_repeat)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(sq_inplace_repeat)
	}
	if !ok {
		panic("failed to find valid type for sq_inplace_repeat")
	}

	return ce(co.InPlaceRepeat(newObject(arg1), int(arg2)))
}
//export goClassSlot_bf_getbuffer
func goClassSlot_bf_getbuffer(obj, arg1 *C.PyObject, arg2 C.int) C.int {
	co, ok := getClassObject(obj).(bf_getbuffer)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(bf_getbuffer)
	}
	if !ok {
		panic("failed to find valid type for bf_getbuffer")
	}

	return err2Int(co.GetBuffer(newObject(arg1), int(arg2)))
}
//export goClassSlot_bf_releasebuffer
func goClassSlot_bf_releasebuffer(obj, arg *C.PyObject) {
	co, ok := getClassObject(obj).(bf_releasebuffer)
	for base := obj.ob_type.tp_base; !ok && base != nil; base = base.tp_base {
		co, ok = getClassObjectByType(obj, base).(bf_releasebuffer)
	}
	if !ok {
		panic("failed to find valid type for bf_releasebuffer")
	}

	co.ReleaseBuffer(newObject(arg))
}

// ===============================================================
// ===============================================================

var slotMap = map[C.uint64_t]reflect.Type{
	C.CLASS_HAS_TP_REPR: reflect.TypeOf((*tp_repr)(nil)).Elem(),
	C.CLASS_HAS_TP_HASH: reflect.TypeOf((*tp_hash)(nil)).Elem(),
	C.CLASS_HAS_TP_CALL: reflect.TypeOf((*tp_call)(nil)).Elem(),
	C.CLASS_HAS_TP_STR: reflect.TypeOf((*tp_str)(nil)).Elem(),
	C.CLASS_HAS_TP_GETATTRO: reflect.TypeOf((*tp_getattro)(nil)).Elem(),
	C.CLASS_HAS_TP_SETATTRO: reflect.TypeOf((*tp_setattro)(nil)).Elem(),
	C.CLASS_HAS_TP_RICHCOMPARE: reflect.TypeOf((*tp_richcompare)(nil)).Elem(),
	C.CLASS_HAS_TP_ITER: reflect.TypeOf((*tp_iter)(nil)).Elem(),
	C.CLASS_HAS_TP_ITERNEXT: reflect.TypeOf((*tp_iternext)(nil)).Elem(),
	C.CLASS_HAS_TP_DESCR_GET: reflect.TypeOf((*tp_descr_get)(nil)).Elem(),
	C.CLASS_HAS_TP_DESCR_SET: reflect.TypeOf((*tp_descr_set)(nil)).Elem(),
	C.CLASS_HAS_TP_INIT: reflect.TypeOf((*tp_init)(nil)).Elem(),
	C.CLASS_HAS_AM_AWAIT: reflect.TypeOf((*am_await)(nil)).Elem(),
	C.CLASS_HAS_AM_AITER: reflect.TypeOf((*am_aiter)(nil)).Elem(),
	C.CLASS_HAS_AM_ANEXT: reflect.TypeOf((*am_anext)(nil)).Elem(),
	C.CLASS_HAS_AM_SEND: reflect.TypeOf((*am_send)(nil)).Elem(),
	C.CLASS_HAS_NB_ADD: reflect.TypeOf((*nb_add)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_ADD: reflect.TypeOf((*nb_inplace_add)(nil)).Elem(),
	C.CLASS_HAS_NB_SUBTRACT: reflect.TypeOf((*nb_subtract)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_SUBTRACT: reflect.TypeOf((*nb_inplace_subtract)(nil)).Elem(),
	C.CLASS_HAS_NB_MULTIPLY: reflect.TypeOf((*nb_multiply)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_MULTIPLY: reflect.TypeOf((*nb_inplace_multiply)(nil)).Elem(),
	C.CLASS_HAS_NB_REMAINDER: reflect.TypeOf((*nb_remainder)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_REMAINDER: reflect.TypeOf((*nb_inplace_remainder)(nil)).Elem(),
	C.CLASS_HAS_NB_DIVMOD: reflect.TypeOf((*nb_divmod)(nil)).Elem(),
	C.CLASS_HAS_NB_POWER: reflect.TypeOf((*nb_power)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_POWER: reflect.TypeOf((*nb_inplace_power)(nil)).Elem(),
	C.CLASS_HAS_NB_NEGATIVE: reflect.TypeOf((*nb_negative)(nil)).Elem(),
	C.CLASS_HAS_NB_POSITIVE: reflect.TypeOf((*nb_positive)(nil)).Elem(),
	C.CLASS_HAS_NB_ABSOLUTE: reflect.TypeOf((*nb_absolute)(nil)).Elem(),
	C.CLASS_HAS_NB_BOOL: reflect.TypeOf((*nb_bool)(nil)).Elem(),
	C.CLASS_HAS_NB_INVERT: reflect.TypeOf((*nb_invert)(nil)).Elem(),
	C.CLASS_HAS_NB_LSHIFT: reflect.TypeOf((*nb_lshift)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_LSHIFT: reflect.TypeOf((*nb_inplace_lshift)(nil)).Elem(),
	C.CLASS_HAS_NB_RSHIFT: reflect.TypeOf((*nb_rshift)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_RSHIFT: reflect.TypeOf((*nb_inplace_rshift)(nil)).Elem(),
	C.CLASS_HAS_NB_AND: reflect.TypeOf((*nb_and)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_AND: reflect.TypeOf((*nb_inplace_and)(nil)).Elem(),
	C.CLASS_HAS_NB_XOR: reflect.TypeOf((*nb_xor)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_XOR: reflect.TypeOf((*nb_inplace_xor)(nil)).Elem(),
	C.CLASS_HAS_NB_OR: reflect.TypeOf((*nb_or)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_OR: reflect.TypeOf((*nb_inplace_or)(nil)).Elem(),
	C.CLASS_HAS_NB_INT: reflect.TypeOf((*nb_int)(nil)).Elem(),
	C.CLASS_HAS_NB_FLOAT: reflect.TypeOf((*nb_float)(nil)).Elem(),
	C.CLASS_HAS_NB_FLOOR_DIVIDE: reflect.TypeOf((*nb_floor_divide)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_FLOOR_DIVIDE: reflect.TypeOf((*nb_inplace_floor_divide)(nil)).Elem(),
	C.CLASS_HAS_NB_TRUE_DIVIDE: reflect.TypeOf((*nb_true_divide)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_TRUE_DIVIDE: reflect.TypeOf((*nb_inplace_true_divide)(nil)).Elem(),
	C.CLASS_HAS_NB_INDEX: reflect.TypeOf((*nb_index)(nil)).Elem(),
	C.CLASS_HAS_NB_MATRIX_MULTIPLY: reflect.TypeOf((*nb_matrix_multiply)(nil)).Elem(),
	C.CLASS_HAS_NB_INPLACE_MATRIX_MULTIPLY: reflect.TypeOf((*nb_inplace_matrix_multiply)(nil)).Elem(),
	C.CLASS_HAS_MP_LENGTH: reflect.TypeOf((*mp_length)(nil)).Elem(),
	C.CLASS_HAS_MP_SUBSCRIPT: reflect.TypeOf((*mp_subscript)(nil)).Elem(),
	C.CLASS_HAS_MP_ASS_SUBSCRIPT: reflect.TypeOf((*mp_ass_subscript)(nil)).Elem(),
	C.CLASS_HAS_SQ_LENGTH: reflect.TypeOf((*sq_length)(nil)).Elem(),
	C.CLASS_HAS_SQ_CONCAT: reflect.TypeOf((*sq_concat)(nil)).Elem(),
	C.CLASS_HAS_SQ_REPEAT: reflect.TypeOf((*sq_repeat)(nil)).Elem(),
	C.CLASS_HAS_SQ_ITEM: reflect.TypeOf((*sq_item)(nil)).Elem(),
	C.CLASS_HAS_SQ_ASS_ITEM: reflect.TypeOf((*sq_ass_item)(nil)).Elem(),
	C.CLASS_HAS_SQ_CONTAINS: reflect.TypeOf((*sq_contains)(nil)).Elem(),
	C.CLASS_HAS_SQ_INPLACE_CONCAT: reflect.TypeOf((*sq_inplace_concat)(nil)).Elem(),
	C.CLASS_HAS_SQ_INPLACE_REPEAT: reflect.TypeOf((*sq_inplace_repeat)(nil)).Elem(),
	C.CLASS_HAS_BF_GETBUFFER: reflect.TypeOf((*bf_getbuffer)(nil)).Elem(),
	C.CLASS_HAS_BF_RELEASEBUFFER: reflect.TypeOf((*bf_releasebuffer)(nil)).Elem(),
}

// ===============================================================
