package main

import "text/template"

var code = template.Must(template.New("code").Parse(`// Code generated by gen_types. DO NOT EDIT.

package py

// #include "utils.h"
import "C"

import (
	"unsafe"
)

// {{ .type }} represents objects of the {{ .type }}Type (or Py{{ .type }}Type
// in the Python API) type.{{ if .funcs.mp_subscript }}
//
// This type implements the Mapping protocol.
{{- end }}{{ if .funcs.sq_item }}
//
// This type implements the Sequence protocol.
{{- end }}{{ if or .funcs.nb_index .funcs.nb_int .funcs.nb_float (eq .type "Complex") }}
//
// This type implements the Number protocol.
{{- end }}
type {{ .type }} struct {
	abstractObject
	o C.Py{{ .type }}Object
}

// {{ .type }}Type is the Type object that represents the {{ .type }} type.
var {{ .type }}Type = (*Type)(unsafe.Pointer(&C.Py{{ .type }}_Type))

func {{ .ltype }}Check(obj Object) bool {
	if obj == nil {
		return false
	}
	return C.{{ .ltype }}Check(c(obj)) != 0
}

func new{{ .type }}(obj *C.PyObject) *{{ .type }} {
	return (*{{ .type }})(unsafe.Pointer(obj))
}

{{ if or .funcs.mp_length .funcs.sq_length -}}
func ({{ .name }} *{{ .type }}) Size() int {
	ret := C.PyObject_Size(c({{ .name }}))
	if ret < 0 {
		clearErr();
		return 0
	}
	return int(ret)
}

{{ end }}

{{- if .funcs.mp_subscript -}}
// AsMapping returns a MappingMethods instance that refers to the same
// underlying Python object as {{ .name }}.
//
// This method also means that {{ .type }} implements the Mapping interface.
func ({{ .name }} *{{ .type }}) AsMapping() *MappingMethods {
	return (*MappingMethods)(unsafe.Pointer({{ .name }}.Base()))
}

func ({{ .name }} *{{ .type }}) GetItemString(key string) (Object, error) {
	cKey := C.CString(key)
	defer C.free(unsafe.Pointer(cKey))
	ret := C.PyMapping_GetItemString(c({{ .name }}), cKey)
	return obj2ObjErr(ret)
}

func ({{ .name }} *{{ .type }}) HasKey(key Object) bool {
	ret := C.PyMapping_HasKey(c({{ .name }}), c(key))
	clearErr();
	return ret > 0
}

func ({{ .name }} *{{ .type }}) HasKeyString(key string) bool {
	cKey := C.CString(key)
	defer C.free(unsafe.Pointer(cKey))
	ret := C.PyMapping_HasKeyString(c({{ .name }}), cKey)
	clearErr();
	return ret > 0
}

{{ end }}

{{- if or .funcs.mp_ass_subscript .funcs.sq_ass_item -}}
func ({{ .name }} *{{ .type }}) DelItem(key Object) error {
	ret := C.PyObject_DelItem(c({{ .name }}), c(key))
	return int2Err(ret)
}

{{ end }}

{{- if .funcs.mp_ass_subscript -}}
func ({{ .name }} *{{ .type }}) DelItemString(key string) error {
	cKey := C.CString(key)
	defer C.free(unsafe.Pointer(cKey))
	ret := C.PyObject_DelItemString(c({{ .name }}), cKey)
	return int2Err(ret)
}

func ({{ .name }} *{{ .type }}) SetItemString(key string, v Object) error {
	cKey := C.CString(key)
	defer C.free(unsafe.Pointer(cKey))
	ret := C.PyMapping_SetItemString(c({{ .name }}), cKey, c(v))
	return int2Err(ret)
}

{{ end }}

{{- if .funcs.sq_item -}}
// AsSequence returns a SequenceMethods instance that refers to the same
// underlying Python object as {{ .name }}.
//
// This method also means that {{ .type }} implements the Sequence interface.
func ({{ .name }} *{{ .type }}) AsSequence() *SequenceMethods {
	return (*SequenceMethods)(unsafe.Pointer({{ .name }}.Base()))
}

func ({{ .name }} *{{ .type }}) GetIndex(idx int) (Object, error) {
	ret := C.PySequence_GetItem(c({{ .name }}), C.Py_ssize_t(idx))
	return obj2ObjErr(ret)
}

func ({{ .name }} *{{ .type }}) Count(obj Object) (int, error) {
	ret := C.PySequence_Count(c({{ .name }}), c(obj))
	return ssize_t2IntErr(ret)
}

func ({{ .name }} *{{ .type }}) Index(obj Object) (int, error) {
	ret := C.PySequence_Index(c({{ .name }}), c(obj))
	return ssize_t2IntErr(ret)
}

{{ end }}

{{- if and .funcs.sq_item (ne .type "List") -}}
func ({{ .name }} *{{ .type }}) List() (*List, error) {
	ret := C.PySequence_List(c({{ .name }}))
	if ret == nil {
		return nil, exception()
	}
	return newList(ret), nil
}

{{ end }}

{{- if and .funcs.sq_item (ne .type "Tuple") -}}
func ({{ .name }} *{{ .type }}) Tuple() (*Tuple, error) {
	ret := C.PySequence_Tuple(c({{ .name }}))
	if ret == nil {
		return nil, exception()
	}
	return newTuple(ret), nil
}

{{ end }}

{{- if .funcs.sq_ass_item -}}
func ({{ .name }} *{{ .type }}) SetIndex(idx int, obj Object) error {
	ret := C.PySequence_SetItem(c({{ .name }}), C.Py_ssize_t(idx), c(obj))
	return int2Err(ret)
}

func ({{ .name }} *{{ .type }}) DelIndex(idx int) error {
	ret := C.PySequence_DelItem(c({{ .name }}), C.Py_ssize_t(idx))
	return int2Err(ret)
}

{{ end }}

{{- if .funcs.sq_concat -}}
func ({{ .name }} *{{ .type }}) Concat(obj Object) (Object, error) {
	ret := C.PySequence_Concat(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.sq_inplace_concat -}}
func ({{ .name }} *{{ .type }}) InPlaceConcat(obj Object) (Object, error) {
	ret := C.PySequence_InPlaceConcat(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.sq_repeat -}}
func ({{ .name }} *{{ .type }}) Repeat(count int) (Object, error) {
	ret := C.PySequence_Repeat(c({{ .name }}), C.Py_ssize_t(count))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.sq_inplace_repeat -}}
func ({{ .name }} *{{ .type }}) InPlaceRepeat(count int) (Object, error) {
	ret := C.PySequence_InPlaceRepeat(c({{ .name }}), C.Py_ssize_t(count))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.sq_contains -}}
func ({{ .name }} *{{ .type }}) Contains(obj Object) (bool, error) {
	ret := C.PySequence_Contains(c({{ .name }}), c(obj))
	return int2BoolErr(ret)
}

{{ end }}

{{- if and .funcs.sq_item .funcs.mp_subscript -}}
func ({{ .name }} *{{ .type }}) GetSlice(start, end int) (Object, error) {
	ret := C.PySequence_GetSlice(c({{ .name }}), C.Py_ssize_t(start), C.Py_ssize_t(end))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if and .funcs.sq_item .funcs.mp_ass_subscript -}}
func ({{ .name }} *{{ .type }}) SetSlice(start, end int, obj Object) error {
	ret := C.PySequence_SetSlice(c({{ .name }}), C.Py_ssize_t(start), C.Py_ssize_t(end), c(obj))
	return int2Err(ret)
}

func ({{ .name }} *{{ .type }}) DelSlice(start, end int) error {
	ret := C.PySequence_DelSlice(c({{ .name }}), C.Py_ssize_t(start), C.Py_ssize_t(end))
	return int2Err(ret)
}

{{ end }}

{{- if or .funcs.nb_index .funcs.nb_int .funcs.nb_float (eq .type "Complex") -}}
// AsNumber returns a NumberMethods instance that refers to the same underlying
// Python object as {{ .name }}.
//
// This method also means that {{ .type }} implements the Number interface.
func ({{ .name }} *{{ .type }}) AsNumber() *NumberMethods {
	return (*NumberMethods)(unsafe.Pointer({{ .name }}.Base()))
}

{{ end }}

{{- if .funcs.nb_add -}}
// Add returns the result of adding {{ .name }} and obj. The equivalent Python is
// "{{ .name }} + obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Add(obj Object) (Object, error) {
	ret := C.PyNumber_Add(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_subtract -}}
// Subtract returns the result of subtracting obj from {{ .name }}. The equivalent Python
// is "{{ .name }} - obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Subtract(obj Object) (Object, error) {
	ret := C.PyNumber_Subtract(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_multiply -}}
// Multiply returns the result of multiplying {{ .name }} by obj. The equivalent Python
// is "{{ .name }} * obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Multiply(obj Object) (Object, error) {
	ret := C.PyNumber_Multiply(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_matrix_multiply -}}
func ({{ .name }} *{{ .type }}) MatrixMultiply(obj Object) (Object, error) {
	ret := C.PyNumber_MatrixMultiply(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_floor_divide -}}
// FloorDivide returns the floor of dividing {{ .name }} by obj. The equivalent Python is
// "{{ .name }} // obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) FloorDivide(obj Object) (Object, error) {
	ret := C.PyNumber_FloorDivide(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_true_divide -}}
// TrueDivide returns the approximate result of dividing {{ .name }} by obj. The result is
// approximate due to the limited representational accuracy of binary floating
// point numbers. The equivalent Python is "{{ .name }} / obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) TrueDivide(obj Object) (Object, error) {
	ret := C.PyNumber_TrueDivide(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_remainder -}}
// Remainder returns the remainder of dividing {{ .name }} by obj. The equivalent Python
// is "{{ .name }} % obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Remainder(obj Object) (Object, error) {
	ret := C.PyNumber_Remainder(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_divmod -}}
// Divmod returns the result of the Python "divmod({{ .name }}, obj)".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Divmod(obj Object) (Object, error) {
	ret := C.PyNumber_Divmod(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_power -}}
// Power returns the result of the Python "pow({{ .name }}, obj1, obj2)", where
// obj2 is optional.
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Power(obj1, obj2 Object) (Object, error) {
	if obj2 == nil {
		None.Incref()
		obj2 = None
	}
	ret := C.PyNumber_Power(c({{ .name }}), c(obj1), c(obj2))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_negative -}}
// Negative returns the negation of {{ .name }}. The equivalent Python is "-{{ .name }}".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Negative() (Object, error) {
	ret := C.PyNumber_Negative(c({{ .name }}))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_positive -}}
// Positive returns the positive of {{ .name }}. The equivalent Python is "+{{ .name }}".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Positive() (Object, error) {
	ret := C.PyNumber_Positive(c({{ .name }}))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_absolute -}}
// Absolute returns the absolute value of {{ .name }}. The equivalent Python is "abs({{ .name }})".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Absolute() (Object, error) {
	ret := C.PyNumber_Absolute(c({{ .name }}))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_invert -}}
// Invert returns the bitwise negation of {{ .name }}. The equivalent Python is "-{{ .name }}".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Invert() (Object, error) {
	ret := C.PyNumber_Invert(c({{ .name }}))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_lshift -}}
// LShift returns the result of left shifting {{ .name }} by obj. The equivalent Python
// is "{{ .name }} << obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) LShift(obj Object) (Object, error) {
	ret := C.PyNumber_Lshift(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_rshift -}}
// RShift returns the result of right shifting {{ .name }} by obj. The equivalent Python
// is "{{ .name }} << obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) RShift(obj Object) (Object, error) {
	ret := C.PyNumber_Rshift(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_and -}}
// And returns the bitwise and of {{ .name }} and obj. The equivalent Python is
// "{{ .name }} & obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) And(obj Object) (Object, error) {
	ret := C.PyNumber_And(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_xor -}}
// Xor returns the bitwise xor of {{ .name }} and obj. The equivalent Python is
// "{{ .name }} ^ obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Xor(obj Object) (Object, error) {
	ret := C.PyNumber_Xor(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_or -}}
// Or returns the bitwise or of {{ .name }} and obj. The equivalent Python is
// "{{ .name }} | obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) Or(obj Object) (Object, error) {
	ret := C.PyNumber_Or(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_add -}}
// InPlaceAdd returns the result of adding {{ .name }} and obj. This is done in place.
// The equivalent Python is "{{ .name }} += obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceAdd(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceAdd(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_subtract -}}
// InPlaceSubtract returns the result of subtracting obj from {{ .name }}. This is done
// in place. The equivalent Python is "{{ .name }} -= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceSubtract(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceSubtract(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_multiply -}}
// InPlaceMultiply returns the result of multiplying {{ .name }} by obj. This is done in
// place. The equivalent Python is "{{ .name }} *= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceMultiply(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceMultiply(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_matrix_multiply -}}
func ({{ .name }} *{{ .type }}) InPlaceMatrixMultiply(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceMatrixMultiply(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_floor_inplace_divide -}}
// InPlaceFloorDivide returns the floor of dividing {{ .name }} by obj. This is done in
// place. The equivalent Python is "{{ .name }} //= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceFloorDivide(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceFloorDivide(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_true_divide -}}
// InPlaceTrueDivide returns the approximate result of dividing {{ .name }} by obj. This
// is done in place. The result is approximate due to the limited
// representational accuracy of binary floating point numbers. The equivalent
// Python is "{{ .name }} /= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceTrueDivide(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceTrueDivide(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_remainder -}}
// InPlaceRemainder returns the remainder of {{ .name }} divided by obj. This is done in
// place. The equivalent Python is "{{ .name }} %= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceRemainder(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceRemainder(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_power -}}
// InPlacePower returns the result of the Python "pow({{ .name }}, obj1, obj2)". This is
// done in place. If obj2 is None, then the Python "{{ .name }} **= obj" is also
// equivalent, if obj2 is not None, there is no equivalent in Python.
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlacePower(obj1, obj2 Object) (Object, error) {
	ret := C.PyNumber_InPlacePower(c({{ .name }}), c(obj1), c(obj2))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_lshift -}}
// InPlaceLShift returns the result of left shifting {{ .name }} by obj. This is done in
// place. The equivalent Python is "{{ .name }} <<= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceLShift(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceLshift(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_rshift -}}
// InPlaceRShift returns the result of right shifting {{ .name }} by obj. This is done in
// place. The equivalent Python is "{{ .name }} >>= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceRShift(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceRshift(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_and -}}
// InPlaceAnd returns the bitwise and of {{ .name }} and obj. This is done in place. The
// equivalent Python is "{{ .name }} &= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceAnd(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceAnd(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_xor -}}
// InPlaceXor returns the bitwise xor of {{ .name }} and obj. This is done in place. The
// equivalent Python is "{{ .name }} ^= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceXor(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceXor(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if .funcs.nb_inplace_or -}}
// InPlaceOr returns the bitwise or of {{ .name }} and obj. This is done in place. The
// equivalent Python is "{{ .name }} |= obj".
//
// Return value: New Reference.
func ({{ .name }} *{{ .type }}) InPlaceOr(obj Object) (Object, error) {
	ret := C.PyNumber_InPlaceOr(c({{ .name }}), c(obj))
	return obj2ObjErr(ret)
}

{{ end }}

{{- if and .funcs.nb_int (ne .type "Long") -}}
func ({{ .name }} *{{ .type }}) Long() (*Long, error) {
	ret := C.PyNumber_Long(c({{ .name }}))
	return newLong(ret), exception()
}

{{ end }}

{{- if and .funcs.nb_float (ne .type "Float") -}}
func ({{ .name }} *{{ .type }}) Float() (*Float, error) {
	ret := C.PyNumber_Float(c({{ .name }}))
	return newFloat(ret), exception()
}

{{ end }}

{{- if .funcs.nb_index -}}
func ({{ .name }} *{{ .type }}) Index() (*Long, error) {
	ret := C.PyNumber_Index(c({{ .name }}))
	return newLong(ret), exception()
}

func ({{ .name }} *{{ .type }}) ToBase(base int) (*Long, error) {
	ret := C.PyNumber_ToBase(c({{ .name }}), C.int(base))
	return newLong(ret), exception()
}

func ({{ .name }} *{{ .type }}) AsInt(exc *ExceptionClass) (int, error) {
	ret := C.PyNumber_AsSsize_t(c({{ .name }}), c(exc))
	return int(ret), exception()
}

{{ end }}

/*
set fields:
{{- range $name, $set := .funcs -}}
{{ if $set }}
  {{ $name }}
{{- end -}}
{{ end }}
*/

`))
