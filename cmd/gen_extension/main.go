package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"text/template"
)

var (
	pkg = flag.String("package", "main", "Name of the package to generate code for")
	fn  = flag.String("func", "initExtension", "Name of the function that creates the module")
)

var fileTemplate = template.Must(template.New("t").Parse(`// Code generated by gen_extension. DO NOT EDIT.

package {{ .package }}

// #include <python3.11/Python.h>
import "C"

import (
	"unsafe"

	"qur.me/py/v3"
)

//export PyInit_{{ .name }}
func PyInit_{{ .name }}() *C.PyObject {
	return (*C.PyObject)(unsafe.Pointer(py.InitExtension({{ .func }})))
}`))

var usage = `%s: [-package PKG] [-func FN] <extension-name> <file-name>

Generate the boilerplate needed for a Python extension module.

In order to create a Python extension in Go we need to generate some boilerplate
code that uses some cgo code to create the necessary C interface. There are two
things that are required for this to work:

 1. A name for the extension. Python expects an extension module called spam.so
    (or spam.dll etc) to have a exported C function called PyInit_spam. This
    program will create the function but needs to know the name to use.

 2. A function that creates the extension module. The PyInit_spam function above
    is supposed to return a created module, so the code created by this command
    needs to call a function that will create the module
    (using py.CreateModule), by default this will be
    "initExtension() (*Module, error)" (the name can be changed using the -func
    command line option, though the signature should stay the same).

To build the extension use the c-shared buildmode:

  go build -buildmode=c-shared -o <extension-name>.so <path-to-code>

The normal Go requirements for building a shared library apply, which means that
you must have exactly one main package (containing an empty main function).

Options:
`

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), usage, os.Args[0])
		flag.PrintDefaults()
	}

	flag.Parse()

	if len(os.Args) < 3 || os.Args[1] == "" {
		flag.Usage()
		os.Exit(1)
	}

	name := os.Args[1]
	filename := os.Args[2]

	v := map[string]string{
		"name":    name,
		"package": *pkg,
		"func":    *fn,
	}

	f, err := os.Create(filename)
	if err != nil {
		log.Fatalf("Failed to create file: %s", err)
	}
	defer f.Close()

	if err := fileTemplate.Execute(f, v); err != nil {
		log.Fatalf("Failed to write file: %s", err)
	}
}
